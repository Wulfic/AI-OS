name: Build ‚Üí Test ‚Üí Publish

on:
  push:
    branches:
      - main  # Only run on main branch pushes
    tags:
      - 'Official'  # Or when Official release tag is pushed
    paths:
      - 'src/**'
      - 'config/**'
      - 'installers/**'
      - 'pyproject.toml'
      - 'requirements*.txt'
      - '.github/workflows/build-test-publish.yml'
  workflow_dispatch:  # Manual trigger
    inputs:
      refresh_lock:
        description: 'Refresh requirements-lock.txt'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip installer tests'
        required: false
        default: false
        type: boolean
      ppa_name:
        description: 'PPA name (e.g., ppa:user/ppa-name)'
        required: false
        default: 'ppa:wulfic/ai-os'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SHORT_SHA: ${{ github.sha }}
  PPA_NAME: ${{ github.event.inputs.ppa_name || 'ppa:wulfic/ai-os' }}

jobs:
  # =============================================================================
  # Prepare version info
  # =============================================================================
  prepare:
    name: üìã Prepare Build Info
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      build_date: ${{ steps.version.outputs.build_date }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Extract version info
        id: version
        run: |
          VERSION=$(grep -oP 'version\s*=\s*"\K[^"]+' pyproject.toml | head -1)
          SHORT_SHA=${GITHUB_SHA::7}
          BUILD_DATE=$(date +'%Y-%m-%d')
          IS_RELEASE=${{ github.ref == 'refs/tags/Official' && 'true' || 'false' }}
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT
          
          echo "üì¶ Version: $VERSION | SHA: $SHORT_SHA | Date: $BUILD_DATE"
          echo "üè∑Ô∏è  Release Build: $IS_RELEASE"

  # =============================================================================
  # Ubuntu/Debian Package Build & Test
  # =============================================================================
  build-deb:
    name: Build & Test Debian Package
    runs-on: ubuntu-22.04
    needs: prepare
    
    steps:
      - name: Free up disk space
        run: |
          echo "üßπ Freeing up disk space..."
          df -h
          echo ""
          echo "Removing unnecessary packages..."
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          sudo apt-get autoremove -y
          sudo apt-get clean
          echo ""
          echo "‚úÖ Disk space after cleanup:"
          df -h
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev
      
      - name: Build .deb package
        run: |
          chmod +x ./installers/_builds/ubuntu/build_deb.sh
          # Always refresh lock file to ensure Python 3.10 compatibility
          ./installers/_builds/ubuntu/build_deb.sh --refresh-lock
      
      - name: Test .deb package structure
        run: |
          echo "üîç Testing .deb package structure..."
          DEB_FILE=$(ls installers/releases/*.deb | head -1)
          
          if [ ! -f "$DEB_FILE" ]; then
            echo "‚ùå ERROR: .deb file not found"
            exit 1
          fi
          
          echo "üì¶ Package: $(basename $DEB_FILE)"
          
          # Check package info
          dpkg-deb --info "$DEB_FILE"
          
          # Check package contents
          echo ""
          echo "üìÇ Package contents:"
          dpkg-deb --contents "$DEB_FILE"
          
          echo "‚úÖ .deb package validation passed"
      
      - name: Test installation (silent mode)
        if: github.event.inputs.skip_tests != 'true'
        run: |
          echo "üß™ Testing .deb installation (silent mode)..."
          DEB_FILE=$(ls installers/releases/*.deb | head -1)
          
          echo "üì¶ Installing package: $(basename $DEB_FILE)"
          
          # Python 3.10+ is already available on Ubuntu 22.04+
          
          # Install the package
          sudo dpkg -i "$DEB_FILE" || true
          
          # Fix any dependency issues
          sudo apt-get install -f -y
          
          # Verify installation
          if dpkg -l | grep -q ai-os; then
            echo "‚úÖ Package installed successfully"
            
            # Check installed files
            echo ""
            echo "üìÇ Installed files:"
            dpkg -L ai-os | head -20
            
            # Check for essential directories and files
            if [ -d "/opt/ai-os" ]; then
              echo "‚úÖ Found: /opt/ai-os directory"
              ls -la /opt/ai-os | head -10
            else
              echo "‚ùå ERROR: Missing /opt/ai-os directory"
              exit 1
            fi
            
            if [ -f "/usr/local/bin/aios" ] || [ -L "/usr/local/bin/aios" ]; then
              echo "‚úÖ Found: /usr/local/bin/aios"
            else
              echo "‚ö†Ô∏è  WARNING: Missing /usr/local/bin/aios"
            fi
            
            # Try to run aios --version if available
            if command -v aios &> /dev/null; then
              echo ""
              echo "üîç Testing aios command:"
              aios --version || echo "‚ö†Ô∏è  aios command exists but version check failed"
            fi
            
            # Clean up - remove the package
            echo ""
            echo "üßπ Cleaning up test installation..."
            sudo dpkg -r ai-os
            
            echo "‚úÖ Installation test completed"
          else
            echo "‚ùå ERROR: Package installation failed"
            dpkg -l | grep ai-os || echo "Package not found in dpkg list"
            exit 1
          fi
      
      - name: Upload .deb artifact
        uses: actions/upload-artifact@v4
        with:
          name: AI-OS-${{ needs.prepare.outputs.version }}-ubuntu-${{ needs.prepare.outputs.short_sha }}
          path: installers/releases/*.deb
          retention-days: 30
          if-no-files-found: error
  
  # =============================================================================
  # Prepare PPA Source Package (Production)
  # =============================================================================
  prepare-ppa:
    name: üì¶ Prepare PPA Source Package (ai-os)
    runs-on: ubuntu-22.04
    needs: [prepare, build-deb]
    if: needs.prepare.outputs.is_release == 'true'
    outputs:
      dsc_file: ${{ steps.build_source.outputs.dsc_file }}
      changes_file: ${{ steps.build_source.outputs.changes_file }}
    
    steps:
      - name: Free up disk space
        run: |
          echo "üßπ Freeing up disk space..."
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          sudo apt-get autoremove -y
          sudo apt-get clean
          df -h
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install Launchpad build tools
        run: |
          echo "üîß Installing Launchpad build dependencies..."
          sudo apt-get update
          sudo apt-get install -y \
            devscripts \
            debhelper \
            dh-python \
            python3-all \
            python3-setuptools \
            dpkg-dev \
            fakeroot \
            lintian \
            dput \
            gnupg2
      
      - name: Import GPG key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.LAUNCHPAD_GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.LAUNCHPAD_GPG_PASSPHRASE }}
        run: |
          echo "üîê Importing GPG key..."
          
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "‚ùå GPG_PRIVATE_KEY secret not set"
            echo "::error title=GPG Key Missing::LAUNCHPAD_GPG_PRIVATE_KEY secret must be configured"
            exit 1
          fi
          
          echo "::add-mask::$GPG_PASSPHRASE"
          echo "$GPG_PRIVATE_KEY" | gpg --batch --quiet --import 2>/dev/null
          
          KEY_ID=$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null | grep sec | awk '{print $2}' | cut -d'/' -f2 | head -1)
          KEY_ID_SHORT=$(echo "$KEY_ID" | tail -c 9)
          echo "key_id=$KEY_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ GPG Key imported (ID: *****$KEY_ID_SHORT)"
          
          # Configure GPG for non-interactive use
          echo "use-agent" > ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" > ~/.gnupg/gpg-agent.conf
          gpg-connect-agent reloadagent /bye 2>/dev/null || true
          
          # Export key ID for signing
          echo "GPG_KEY_ID=$KEY_ID" >> $GITHUB_ENV
      
      - name: Build source package for PPA
        id: build_source
        env:
          DEBEMAIL: ${{ secrets.LAUNCHPAD_GPG_EMAIL }}
          DEBFULLNAME: "wulfic"
        run: |
          echo "üì¶ Building source package for PPA..."
          
          VERSION="${{ needs.prepare.outputs.version }}"
          PACKAGE_NAME="ai-os"
          BUILD_DIR="${PACKAGE_NAME}-${VERSION}"
          
          echo "Version: $VERSION"
          echo "Build directory: $BUILD_DIR"
          
          # Check if custom source package script exists
          if [ -f "installers/_builds/ubuntu/create_source_package.sh" ]; then
            chmod +x "installers/_builds/ubuntu/create_source_package.sh"
            "installers/_builds/ubuntu/create_source_package.sh"
          else
            echo "‚ö†Ô∏è  Source package script not found, creating basic structure..."
            
            # Create properly named build directory
            mkdir -p "$BUILD_DIR"
            
            # Copy source files excluding build artifacts
            echo "üìÅ Copying source files..."
            rsync -av ./ "$BUILD_DIR/" \
              --exclude=".git" \
              --exclude="build" \
              --exclude="dist" \
              --exclude="*.egg-info" \
              --exclude="__pycache__" \
              --exclude=".venv" \
              --exclude="artifacts" \
              --exclude="${PACKAGE_NAME}-*" \
              --exclude="installers/_builds" \
              --exclude="installers/releases"
            
            # Create debian directory
            mkdir -p "$BUILD_DIR/debian"
            
            # Create debian/control
            printf '%s\n' \
              'Source: ai-os' \
              'Section: devel' \
              'Priority: optional' \
              'Maintainer: wulfic <${{ secrets.LAUNCHPAD_GPG_EMAIL }}>' \
              'Build-Depends: debhelper-compat (= 12), dh-python, python3-all (>= 3.10), python3-setuptools' \
              'Standards-Version: 4.5.1' \
              'Homepage: https://github.com/Wulfic/AI-OS' \
              '' \
              'Package: ai-os' \
              'Architecture: all' \
              'Depends: ${python3:Depends}, ${misc:Depends}, python3 (>= 3.10), python3-pip, python3-venv, ffmpeg' \
              'Description: AI Operating System - Advanced AI Development Framework' \
              ' AI-OS provides an advanced framework for AI model development with' \
              ' recursive hierarchical reasoning capabilities, multi-modal support,' \
              ' and adaptive learning features.' \
              > "$BUILD_DIR/debian/control"
            
            # Create debian/changelog
            printf '%s\n' \
              "ai-os ($VERSION-1) unstable; urgency=medium" \
              '' \
              "  * Production release $VERSION" \
              '  * See GitHub releases for full changelog' \
              '' \
              " -- wulfic <${{ secrets.LAUNCHPAD_GPG_EMAIL }}>  $(date -R)" \
              > "$BUILD_DIR/debian/changelog"
            
            # Create debian/rules
            printf '%s\n' \
              '#!/usr/bin/make -f' \
              '' \
              '%:' \
              '	dh $@' \
              '' \
              'override_dh_auto_clean:' \
              '	# Skip Python build cleanup' \
              '' \
              'override_dh_auto_build:' \
              '	# Skip Python build' \
              '' \
              'override_dh_auto_install:' \
              '	# Skip Python install' \
              > "$BUILD_DIR/debian/rules"
            chmod +x "$BUILD_DIR/debian/rules"
            
            # Create debian/source/format
            mkdir -p "$BUILD_DIR/debian/source"
            echo "3.0 (quilt)" > "$BUILD_DIR/debian/source/format"
            
            # Note: No debian/compat file needed - using debhelper-compat in Build-Depends
            
            # Create source tarball (.orig.tar.gz)
            # Use full version including -dev suffix
            echo "üì¶ Creating original source tarball: ${PACKAGE_NAME}_${VERSION}.orig.tar.gz"
            tar --exclude-vcs --exclude="$BUILD_DIR/debian" \
                -czf "${PACKAGE_NAME}_${VERSION}.orig.tar.gz" "$BUILD_DIR"
            
            # Verify tarball was created
            if [ ! -f "${PACKAGE_NAME}_${VERSION}.orig.tar.gz" ]; then
              echo "‚ùå Failed to create tarball"
              ls -la
              exit 1
            fi
            
            echo "‚úÖ Tarball created: $(ls -lh ${PACKAGE_NAME}_${VERSION}.orig.tar.gz)"
            
            # Build source package
            echo "üî® Building source package..."
            cd "$BUILD_DIR"
            
            # Run debuild with full output on error
            if ! debuild -S -sa -us -uc --no-check-builddeps 2>&1; then
              echo "‚ùå debuild failed"
              echo ""
              echo "üìÇ Directory contents:"
              ls -la
              echo ""
              echo "üìÇ debian/ contents:"
              ls -la debian/ || true
              exit 1
            fi
            
            cd ..
          fi
          
          # Find generated files
          echo "üîç Searching for source package files..."
          echo "Files in current directory:"
          ls -la *.dsc *.changes *.tar.* 2>/dev/null || echo "No source files in root yet"
          
          DSC_FILE=$(find . -maxdepth 1 -name "*.dsc" | head -1)
          CHANGES_FILE=$(find . -maxdepth 1 -name "*_source.changes" | head -1)
          
          if [ -z "$DSC_FILE" ] || [ -z "$CHANGES_FILE" ]; then
            echo "‚ùå Source package files not found"
            echo "Expected: ${PACKAGE_NAME}_${VERSION}-1.dsc and ${PACKAGE_NAME}_${VERSION}-1_source.changes"
            echo "All files in directory:"
            ls -laR
            exit 1
          fi
          
          echo "üì¶ Found .dsc file: $DSC_FILE"
          echo "üì¶ Found .changes file: $CHANGES_FILE"
          
          echo "dsc_file=$DSC_FILE" >> $GITHUB_OUTPUT
          echo "changes_file=$CHANGES_FILE" >> $GITHUB_OUTPUT
          echo "‚úÖ Source package built successfully"
      
      - name: Sign source package
        env:
          GPG_PASSPHRASE: ${{ secrets.LAUNCHPAD_GPG_PASSPHRASE }}
        run: |
          echo "üîè Signing source package..."
          echo "::add-mask::$GPG_PASSPHRASE"
          
          CHANGES_FILE="${{ steps.build_source.outputs.changes_file }}"
          
          echo "üìù Changes file to sign: $CHANGES_FILE"
          
          # Verify file exists
          if [ ! -f "$CHANGES_FILE" ]; then
            echo "‚ùå Changes file not found at: $CHANGES_FILE"
            exit 1
          fi
          
          # List GPG keys
          echo "üîë Available GPG keys:"
          gpg --list-secret-keys
          
          # Sign with debsign using GPG in loopback mode
          if [ -n "$GPG_PASSPHRASE" ]; then
            echo "üîê Signing with passphrase..."
            debsign -p"gpg --batch --pinentry-mode loopback --passphrase-fd 0" -k"$GPG_KEY_ID" "$CHANGES_FILE" <<< "$GPG_PASSPHRASE"
          else
            echo "üîê Signing without passphrase..."
            debsign -k"$GPG_KEY_ID" "$CHANGES_FILE"
          fi
          
          # Verify signature
          echo "üîç Verifying signature..."
          gpg --verify "$CHANGES_FILE" 2>&1 || {
            echo "‚ùå Signature verification failed"
            exit 1
          }
          
          echo "‚úÖ Package signed and verified successfully"
      
      - name: Validate package with lintian
        run: |
          echo "üîç Validating package..."
          CHANGES_FILE="${{ steps.build_source.outputs.changes_file }}"
          lintian -I -E --pedantic "$CHANGES_FILE" || true
          echo "‚úÖ Validation complete"
      
      - name: Upload PPA source artifacts
        uses: actions/upload-artifact@v4
        with:
          name: launchpad-source-package
          path: |
            *.dsc
            *.tar.*
            *.changes
            *.buildinfo
          retention-days: 30

  # =============================================================================
  # Upload to PPA (Production)
  # =============================================================================
  publish-ppa:
    name: üì§ Upload to PPA (ai-os)
    needs: [prepare, prepare-ppa]
    runs-on: ubuntu-22.04
    
    steps:
      - name: Download source package
        uses: actions/download-artifact@v4
        with:
          name: launchpad-source-package
          path: package
      
      - name: Install dput
        run: |
          sudo apt-get update
          sudo apt-get install -y dput gnupg2
      
      - name: Configure dput for Launchpad
        run: |
          mkdir -p ~/.dput.d
          
          printf '%s\n' \
            '[DEFAULT]' \
            'default_host_main = ppa' \
            '' \
            '[ppa]' \
            'fqdn = ppa.launchpad.net' \
            'method = ftp' \
            'incoming = ~%(ppa)s/ubuntu' \
            'login = anonymous' \
            'allow_unsigned_uploads = 0' \
            > ~/.dput.cf
          
          echo "‚úÖ dput configured"
      
      - name: Import GPG key for upload
        env:
          GPG_PRIVATE_KEY: ${{ secrets.LAUNCHPAD_GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.LAUNCHPAD_GPG_PASSPHRASE }}
        run: |
          echo "üîê Importing GPG key for upload..."
          echo "::add-mask::$GPG_PASSPHRASE"
          echo "$GPG_PRIVATE_KEY" | gpg --batch --quiet --import 2>/dev/null
          echo "‚úÖ GPG key ready for signing"
      
      - name: Upload to PPA
        run: |
          echo "üì§ Uploading to ${{ env.PPA_NAME }}..."
          
          cd package
          
          echo "üìÇ Files in package directory:"
          ls -la
          
          CHANGES_FILE=$(find . -name "*_source.changes" | head -1)
          
          if [ -z "$CHANGES_FILE" ]; then
            echo "‚ùå Source changes file not found"
            echo "Available files:"
            ls -la
            exit 1
          fi
          
          PPA_PATH=$(echo "${{ env.PPA_NAME }}" | sed 's/ppa://')
          
          echo "üì§ Uploading: $CHANGES_FILE"
          dput "ppa:$PPA_PATH" "$CHANGES_FILE"
          
          echo "‚úÖ Package uploaded successfully to ${{ env.PPA_NAME }}"
  
  # =============================================================================
  # Windows Installer Build & Test
  # =============================================================================
  build-windows:
    name: Build & Test Windows Installer
    runs-on: windows-latest
    needs: prepare
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install Inno Setup
        run: |
          # Download Inno Setup 6 with retry logic
          $innoUrls = @(
            "https://jrsoftware.org/download.php/is.exe",
            "https://files.jrsoftware.org/is/6/innosetup-6.3.3.exe"
          )
          $innoInstaller = "$env:TEMP\innosetup.exe"
          $maxRetries = 3
          $downloaded = $false
          
          foreach ($url in $innoUrls) {
            for ($i = 1; $i -le $maxRetries; $i++) {
              try {
                Write-Host "Downloading Inno Setup from $url (attempt $i/$maxRetries)..."
                Invoke-WebRequest -Uri $url -OutFile $innoInstaller -UseBasicParsing -TimeoutSec 30
                $downloaded = $true
                Write-Host "‚úÖ Download successful"
                break
              } catch {
                Write-Host "‚ö†Ô∏è  Download failed: $($_.Exception.Message)"
                if ($i -lt $maxRetries) {
                  Start-Sleep -Seconds 5
                }
              }
            }
            if ($downloaded) { break }
          }
          
          if (-not $downloaded) {
            Write-Error "Failed to download Inno Setup from all sources"
            exit 1
          }
          
          Write-Host "Installing Inno Setup silently..."
          Start-Process -FilePath $innoInstaller -ArgumentList "/VERYSILENT", "/SUPPRESSMSGBOXES", "/NORESTART", "/SP-" -Wait
          
          # Add to PATH for this session
          $innoPath = "C:\Program Files (x86)\Inno Setup 6"
          echo "$innoPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          
          Write-Host "‚úÖ Inno Setup installed successfully"
        shell: pwsh
      
      - name: Build Windows installer
        run: |
          & .\installers\_builds\windows\build_windows_installer.ps1
        shell: pwsh
      
      - name: Test installer structure
        run: |
          Write-Host "üîç Testing Windows installer structure..."
          
          $installerFile = Get-ChildItem -Path "installers\releases\*.exe" | Select-Object -First 1
          
          if (-not $installerFile) {
            Write-Host "‚ùå ERROR: Installer file not found"
            exit 1
          }
          
          Write-Host "üì¶ Installer: $($installerFile.Name)"
          Write-Host "üìä Size: $([math]::Round($installerFile.Length / 1MB, 2)) MB"
          
          # Check if file is a valid PE executable
          $fileHeader = [System.IO.File]::ReadAllBytes($installerFile.FullName)[0..1]
          if ($fileHeader[0] -eq 0x4D -and $fileHeader[1] -eq 0x5A) {
            Write-Host "‚úÖ Valid Windows executable (PE format)"
          } else {
            Write-Host "‚ùå ERROR: Not a valid Windows executable"
            exit 1
          }
          
          Write-Host "‚úÖ Installer validation passed"
        shell: pwsh
      
      - name: Test installation (silent mode)
        if: github.event.inputs.skip_tests != 'true'
        run: |
          Write-Host "üß™ Testing Windows installation (silent mode)..."
          
          # Check if running as admin
          $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
          Write-Host "üîê Running as admin: $isAdmin"
          
          $installerFile = Get-ChildItem -Path "installers\releases\*.exe" | Select-Object -First 1
          $testInstallDir = "$env:TEMP\AI-OS-Test-$([guid]::NewGuid().ToString().Substring(0,8))"
          $logFile = "$env:TEMP\aios-install-test.log"
          
          Write-Host "üì¶ Installer: $($installerFile.Name)"
          Write-Host "üìÇ Test installation directory: $testInstallDir"
          
          # Run installer in silent mode with custom directory
          # GitHub Actions runners run with admin privileges by default
          $arguments = "/VERYSILENT", "/SUPPRESSMSGBOXES", "/NORESTART", "/DIR=$testInstallDir", "/LOG=$logFile"
          $process = Start-Process -FilePath $installerFile.FullName -ArgumentList $arguments -PassThru -Wait -NoNewWindow
          
          Write-Host "üìä Installer exit code: $($process.ExitCode)"
          
          if ($process.ExitCode -ne 0) {
            Write-Host "‚ö†Ô∏è  WARNING: Installation may have failed"
            if (Test-Path $logFile) {
              Write-Host ""
              Write-Host "üìã Last 50 lines of installer log:"
              Get-Content $logFile -Tail 50 | Write-Host
            }
          }
          
          # Check if installation directory was created
          Start-Sleep -Seconds 2  # Give the installer time to complete
          
          if (Test-Path $testInstallDir) {
            Write-Host ""
            Write-Host "‚úÖ Installation directory created"
            
            # List top-level files and directories
            Write-Host ""
            Write-Host "üìÇ Top-level files and directories:"
            Get-ChildItem -Path $testInstallDir | Format-Table Name, Length, Mode -AutoSize
            
            # Check for essential files
            Write-Host ""
            Write-Host "üîç Checking for essential files..."
            $essentialFiles = @(
              "launcher.bat",
              "pyproject.toml",
              "LICENSE"
            )
            
            $missingCount = 0
            foreach ($file in $essentialFiles) {
              $filePath = Join-Path $testInstallDir $file
              if (Test-Path $filePath) {
                Write-Host "  ‚úÖ Found: $file"
              } else {
                Write-Host "  ‚ùå Missing: $file"
                $missingCount++
              }
            }
            
            # Clean up test installation
            Write-Host ""
            Write-Host "üßπ Cleaning up test installation..."
            Remove-Item -Path $testInstallDir -Recurse -Force -ErrorAction SilentlyContinue
            
            if ($missingCount -eq 0) {
              Write-Host "‚úÖ Installation test completed successfully"
            } else {
              Write-Host "‚ùå ERROR: Installation test failed - $missingCount essential files missing"
              exit 1
            }
          } else {
            Write-Host ""
            Write-Host "‚ùå ERROR: Installation directory not found"
            Write-Host "This typically means the installer failed to run or was unable to create the directory."
            
            if ($process.ExitCode -ne 0) {
              Write-Host "Installer exit code: $($process.ExitCode)"
            }
            
            Write-Host "‚ùå Installation test failed"
            exit 1
          }
        shell: pwsh
      
      - name: Upload Windows installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: AI-OS-${{ needs.prepare.outputs.version }}-windows-${{ needs.prepare.outputs.short_sha }}
          path: installers/releases/*.exe
          retention-days: 30
          if-no-files-found: error

  # =============================================================================
  # STAGE 4: PUBLISH TO GITHUB RELEASE
  # =============================================================================
  publish-release:
    name: üì¶ Publish GitHub Release
    needs: [prepare, build-deb, build-windows]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.prepare.outputs.is_release == 'true' &&
      needs.build-deb.result == 'success' &&
      needs.build-windows.result == 'success'
    
    permissions:
      contents: write
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: AI-OS v${{ needs.prepare.outputs.version }}
          tag_name: Official
          files: |
            artifacts/**/*.deb
            artifacts/**/*.exe
          body: |
            ## AI-OS v${{ needs.prepare.outputs.version }}
            
            ‚úÖ **Installation Verified**
            
            ### üì• Installation
            
            **Windows:**
            Download `AI-OS-Setup.exe` and run the installer.
            
            **Ubuntu/Debian:**
            ```bash
            sudo dpkg -i AI-OS_*.deb
            sudo apt-get install -f
            ```
            
            Or install via APT repository (available shortly after release):
            ```bash
            sudo add-apt-repository ${{ env.PPA_NAME }}
            sudo apt update
            sudo apt install ai-os
            ```
            
            **Note:** Allow 5-15 minutes after release for PPA build to complete.
          generate_release_notes: true
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # =============================================================================
  # Summary Report
  # =============================================================================
  summary:
    name: üìä Build Summary
    needs: [prepare, build-deb, build-windows, prepare-ppa, publish-ppa, publish-release]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Generate summary
        run: |
          echo "# üöÄ Build ‚Üí Test ‚Üí Publish Pipeline" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ needs.prepare.outputs.short_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build Date:** ${{ needs.prepare.outputs.build_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** ${{ needs.prepare.outputs.is_release }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| üî® Build Debian | ${{ needs.build-deb.result == 'success' && '‚úÖ' || needs.build-deb.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.build-deb.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| üî® Build Windows | ${{ needs.build-windows.result == 'success' && '‚úÖ' || needs.build-windows.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.build-windows.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| üì¶ GitHub Release | ${{ needs.publish-release.result == 'success' && '‚úÖ' || needs.publish-release.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.publish-release.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| üì¶ Prepare PPA Source | ${{ needs.prepare-ppa.result == 'success' && '‚úÖ' || needs.prepare-ppa.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.prepare-ppa.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| üì§ Upload to PPA | ${{ needs.publish-ppa.result == 'success' && '‚úÖ' || needs.publish-ppa.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.publish-ppa.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üì¶ PPA Repository (Production)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "After PPA build completes (5-15 minutes), install via:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "sudo add-apt-repository ${{ env.PPA_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "sudo apt update" >> $GITHUB_STEP_SUMMARY
          echo "sudo apt install ai-os" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
